<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>双组线圈 + 小圆片磁场 + 感应电流曲线</title>
<style>
body { margin:0; overflow:hidden; background:#202020; font-family:sans-serif; }
canvas { display:block; background:#202020; }
#controls {
  position: absolute; top: 10px; left: 10px;
  background: rgba(40,40,40,0.9); padding: 15px;
  border-radius: 8px; color: #fff; font-size: 14px;
  width: 280px;
}
#controls label { display:block; margin:8px 0 3px; }
#controls input[type=range] { width: 160px; margin-left:5px; vertical-align: middle; }
#controls span { display:inline-block; width:30px; text-align:right; margin-left:5px; }
#controls button { margin-top:8px; width:100%; padding:4px; border:none; border-radius:4px; background:#555; color:#fff; cursor:pointer;}
#controls button:hover { background:#777; }
#info { position:absolute; bottom:10px; left:10px; color:#fff; background: rgba(40,40,40,0.9); padding:10px; border-radius:8px; font-size:14px;}
</style>
</head>
<body>
<div id="controls">
  <label>励磁线圈半径: <input type="range" id="excRadius" min="0.5" max="5" step="0.1" value="2"><span id="excRadiusVal">2</span></label>
  <label>感应线圈半径: <input type="range" id="indRadius" min="0.5" max="5" step="0.1" value="1.6"><span id="indRadiusVal">1.6</span></label>
  <label>组内距离: <input type="range" id="componentSpacing" min="0.5" max="5" step="0.1" value="3"><span id="componentSpacingVal">3</span></label>
  <label>组间距: <input type="range" id="groupSpacing" min="1" max="10" step="0.1" value="6"><span id="groupSpacingVal">6</span></label>
  <label>电流大小: <input type="range" id="current" min="0.1" max="5" step="0.1" value="1"><span id="currentVal">1</span></label>
  <label>积分分段: <input type="range" id="segments" min="10" max="500" step="10" value="100"><span id="segmentsVal">100</span></label>
  <label>空间采样间距: <input type="range" id="spaceStep" min="1" max="5" step="1" value="2"><span id="spaceStepVal">2</span></label>
  <label>小圆片速度: <input type="range" id="discSpeed" min="0.01" max="0.5" step="0.01" value="0.05"><span id="discSpeedVal">0.05</span></label>
  <label>小圆片磁化: <input type="range" id="discMag" min="0.1" max="5" step="0.1" value="1"><span id="discMagVal">1</span></label>
  <button id="resetBtn">重置小圆片位置</button>
</div>
<canvas id="currentCanvas" width="600" height="200" style="position:absolute;top:10px; right:10px;"></canvas>
<div id="info">测量速度: 0 m/s</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
<script>
// ---------------- 3D场景 ----------------
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
camera.position.set(20,20,25);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0x404040));
const dirLight = new THREE.DirectionalLight(0xffffff,1);
dirLight.position.set(10,10,10);
scene.add(dirLight);
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
scene.add(new THREE.GridHelper(30,30));
scene.add(new THREE.AxesHelper(5));

let coilMeshes=[], arrowGroups=[];
let disc=null, discPos=new THREE.Vector3(0,0,-5), discVel=new THREE.Vector3(0,0,0.05), discMagnetization=1;

// -------- 创建线圈 --------
function createCoil(position,radius,color,axis){
    const geo = new THREE.TorusGeometry(radius,0.1,16,100);
    const mat = new THREE.MeshStandardMaterial({color});
    const mesh = new THREE.Mesh(geo,mat);
    const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), axis.clone().normalize());
    mesh.quaternion.copy(q);
    mesh.position.copy(position);
    scene.add(mesh);
    mesh.axisQuaternion = q;
    mesh.radius = radius;
    mesh.positionVec = position.clone();
    return mesh;
}

// -------- 数值积分计算励磁线圈磁场 --------
function computeMagField(coil,point,segments,current){
    const mu0 = 4*Math.PI*1e-7;
    let B = new THREE.Vector3(0,0,0);
    for(let i=0;i<segments;i++){
        const theta = 2*Math.PI*i/segments;
        const nextTheta = 2*Math.PI*(i+1)/segments;
        let p1 = new THREE.Vector3(Math.cos(theta)*coil.radius, Math.sin(theta)*coil.radius,0);
        let p2 = new THREE.Vector3(Math.cos(nextTheta)*coil.radius, Math.sin(nextTheta)*coil.radius,0);
        p1.applyQuaternion(coil.axisQuaternion).add(coil.positionVec);
        p2.applyQuaternion(coil.axisQuaternion).add(coil.positionVec);
        const dl = new THREE.Vector3().subVectors(p2,p1);
        const r = new THREE.Vector3().subVectors(point,p1);
        const len = r.length();
        if(len>1e-6){
            const dB = dl.clone().cross(r).multiplyScalar(mu0*current/(4*Math.PI*Math.pow(len,3)));
            B.add(dB);
        }
    }
    return B;
}

// -------- 小圆片磁场（点偶极） --------
function computeDiscField(point){
    const mu0 = 4*Math.PI*1e-7;
    const r = point.clone().sub(discPos);
    const rLen = r.length();
    if(rLen<0.01) return new THREE.Vector3(0,0,0);
    const m = new THREE.Vector3(0,0,discMagnetization);
    return r.clone().multiplyScalar(3*r.dot(m)).sub(m.clone().multiplyScalar(rLen*rLen)).multiplyScalar(mu0/(4*Math.PI*Math.pow(rLen,5)));
}

// -------- 创建场景 --------
let indCoils=[];
function createScene(params){
    coilMeshes.forEach(c=>scene.remove(c));
    coilMeshes=[]; arrowGroups.forEach(a=>scene.remove(a)); arrowGroups=[];
    const axis = new THREE.Vector3(0,0,1);
    const basePos = new THREE.Vector3(0,0,0);
    const offset = axis.clone().multiplyScalar(params.groupSpacing);

    const exc1 = createCoil(basePos.clone().sub(axis.clone().multiplyScalar(params.componentSpacing/2)), params.excRadius, 0xff0000, axis);
    const exc2 = createCoil(basePos.clone().add(offset).sub(axis.clone().multiplyScalar(params.componentSpacing/2)), params.excRadius, 0xff0000, axis);
    const ind1 = createCoil(basePos.clone().add(axis.clone().multiplyScalar(params.componentSpacing/2)), params.indRadius, 0x00aaff, axis);
    const ind2 = createCoil(basePos.clone().add(offset).add(axis.clone().multiplyScalar(params.componentSpacing/2)), params.indRadius, 0x00aaff, axis);

    coilMeshes.push(exc1,exc2,ind1,ind2);
    indCoils=[ind1,ind2];

    // 小圆片
    if(disc) scene.remove(disc);
    const geo = new THREE.CylinderGeometry(params.indRadius*0.4, params.indRadius*0.4, 0.2, 32);
    const mat = new THREE.MeshStandardMaterial({color:0x00ff00});
    disc = new THREE.Mesh(geo,mat);
    disc.rotation.x = Math.PI/2;
    discPos.set(0,0,-5);
    disc.position.copy(discPos);
    discVel.set(0,0,params.discSpeed);
    discMagnetization=params.discMag;
    scene.add(disc);

    // 空间磁场箭头
    const positions = [exc1.positionVec, exc2.positionVec, discPos];
    const extraMargin = params.spaceStep*4;
    const minX = Math.min(...positions.map(p=>p.x))-extraMargin;
    const maxX = Math.max(...positions.map(p=>p.x))+extraMargin;
    const minY = Math.min(...positions.map(p=>p.y))-extraMargin;
    const maxY = Math.max(...positions.map(p=>p.y))+extraMargin;
    const minZ = Math.min(...positions.map(p=>p.z))-extraMargin;
    const maxZ = Math.max(...positions.map(p=>p.z))+extraMargin;

    for(let x=minX;x<=maxX;x+=params.spaceStep){
        for(let y=minY;y<=maxY;y+=params.spaceStep){
            for(let z=minZ;z<=maxZ;z+=params.spaceStep){
                const pt = new THREE.Vector3(x,y,z);
                let B_total = new THREE.Vector3(0,0,0);
                [exc1,exc2].forEach(c=>{ B_total.add(computeMagField(c,pt,params.segments,params.current)); });
                B_total.add(computeDiscField(pt));
                const len = B_total.length()*1e6;
                if(len>0){
                    const arrow = new THREE.ArrowHelper(B_total.clone().normalize(), pt, len, 0xffff00);
                    arrow.positionVec = pt.clone();
                    scene.add(arrow);
                    arrowGroups.push(arrow);
                }
            }
        }
    }
    return [exc1,exc2,ind1,ind2];
}

// -------- 获取参数 --------
function getParams(){
    return {
        excRadius: parseFloat(document.getElementById('excRadius').value),
        indRadius: parseFloat(document.getElementById('indRadius').value),
        componentSpacing: parseFloat(document.getElementById('componentSpacing').value),
        groupSpacing: parseFloat(document.getElementById('groupSpacing').value),
        current: parseFloat(document.getElementById('current').value),
        segments: parseInt(document.getElementById('segments').value),
        spaceStep: parseFloat(document.getElementById('spaceStep').value),
        discSpeed: parseFloat(document.getElementById('discSpeed').value),
        discMag: parseFloat(document.getElementById('discMag').value)
    };
}

// -------- 初始化 --------
let [exc1,exc2,ind1,ind2] = createScene(getParams());

// -------- 曲线显示 --------
const canvas = document.getElementById('currentCanvas');
const ctx = canvas.getContext('2d');
let fluxData1=[], fluxData2=[], currentData1=[], currentData2=[];
const dt = 0.05;
let peakTimes1=[], peakTimes2=[], lastPeak1=-Infinity, lastPeak2=-Infinity;

// -------- 计算磁通量 --------
function computeFlux(coil){
    // 这里简单用中心点磁场乘线圈面积近似
    const point = coil.positionVec.clone();
    const B = new THREE.Vector3(0,0,0);
    [exc1,exc2].forEach(c=>{ B.add(computeMagField(c,point,getParams().segments,getParams().current)); });
    B.add(computeDiscField(point));
    const area = Math.PI*Math.pow(coil.radius,2);
    return B.dot(new THREE.Vector3(0,0,1))*area;
}

// -------- 峰值检测 --------
function detectPeak(data,lastPeakTime,t){
    const n = data.length;
    if(n<3) return null;
    if(data[n-2] > data[n-3] && data[n-2] > data[n-1]){
        if(t - lastPeakTime > 0.01) return n-2;
    }
    return null;
}

// -------- 动画循环 --------
function animate(){
    requestAnimationFrame(animate);

    // 励磁旋转
    [exc1,exc2].forEach(c=>c.rotation.z+=0.02);

    // 小圆片运动
    discPos.add(discVel);
    disc.position.copy(discPos);
    if(discPos.z > 10) discPos.z = -5;

    // 更新箭头
    arrowGroups.forEach(a=>{
        let B_total = new THREE.Vector3(0,0,0);
        [exc1,exc2].forEach(c=>{ B_total.add(computeMagField(c,a.positionVec,getParams().segments,getParams().current)); });
        B_total.add(computeDiscField(a.positionVec));
        a.setDirection(B_total.clone().normalize());
        a.setLength(B_total.length()*1e6);
    });

    // -------- 感应电流计算 --------
    const flux1 = computeFlux(indCoils[0]);
    const flux2 = computeFlux(indCoils[1]);
    const I1 = fluxData1.length>0 ? -(flux1 - fluxData1[fluxData1.length-1])/dt : 0;
    const I2 = fluxData2.length>0 ? -(flux2 - fluxData2[fluxData2.length-1])/dt : 0;
    fluxData1.push(flux1); fluxData2.push(flux2);
    currentData1.push(I1); currentData2.push(I2);

    // 峰值检测
    const t = fluxData1.length*dt;
    const p1 = detectPeak(currentData1,lastPeak1,t);
    if(p1!==null){ 
        if(lastPeak1!==-Infinity){
            const v = getParams().componentSpacing/dt/(p1-lastPeak1);
            document.getElementById('info').innerText = "测量速度: "+v.toFixed(3)+" m/s";
        }
        lastPeak1 = p1*dt;
    }
    const p2 = detectPeak(currentData2,lastPeak2,t);
    if(p2!==null){ lastPeak2 = p2*dt; }

    // -------- 绘制曲线 --------
    ctx.fillStyle = "#202020";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    const maxVal = Math.max(...currentData1.map(Math.abs), ...currentData2.map(Math.abs),1e-6);
    const scale = canvas.height/2/maxVal*0.9;
    ctx.strokeStyle = "#ff0000";
    ctx.beginPath();
    currentData1.forEach((val,i)=>{
        const x = i; const y = canvas.height/2 - val*scale;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();
    ctx.strokeStyle="#00ffff";
    ctx.beginPath();
    currentData2.forEach((val,i)=>{
        const x = i; const y = canvas.height/2 - val*scale;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();

    controls.update();
    renderer.render(scene,camera);
}
animate();

// -------- 滑条绑定 --------
['excRadius','indRadius','componentSpacing','groupSpacing','current','segments','spaceStep','discSpeed','discMag'].forEach(id=>{
    const slider = document.getElementById(id);
    const valSpan = document.getElementById(id+'Val');
    slider.addEventListener('input',()=>{
        valSpan.innerText = slider.value;
        [exc1,exc2,ind1,ind2] = createScene(getParams());
        fluxData1=[]; fluxData2=[]; currentData1=[]; currentData2=[];
        lastPeak1=-Infinity; lastPeak2=-Infinity;
    });
});

// -------- 重置按钮 --------
document.getElementById('resetBtn').addEventListener('click',()=>{
    discPos.set(0,0,-5);
    disc.position.copy(discPos);
    fluxData1=[]; fluxData2=[]; currentData1=[]; currentData2=[];
    lastPeak1=-Infinity; lastPeak2=-Infinity;
    document.getElementById('info').innerText="测量速度: 0 m/s";
});

// -------- 窗口自适应 --------
window.addEventListener("resize",()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
